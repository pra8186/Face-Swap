# -*- coding: utf-8 -*-
"""Face_Swap.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ePRIgMbUgYJ1U9zvjttHeamD7pldY4xI
"""

import cv2
import numpy as np
import dlib
from google.colab.patches import cv2_imshow

img=cv2.imread('/content/tamannah.jpg')
#img=cv2.GaussianBlur(img,(5,5),0)
img_1=cv2.imread('/content/kajal.jpg')
#img_1=cv2.GaussianBlur(img_1,(5,5),0)
imggray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
img_1gray=cv2.cvtColor(img_1,cv2.COLOR_BGR2GRAY)
img2_newface=np.zeros_like(img_1)
mask=np.zeros_like(imggray)
#cv2_imshow(img)
#cv2_imshow(img_1)

def get_index(array):
  index=None
  for num in array[0]:
    index=num
    break
  return index

detector=dlib.get_frontal_face_detector()
predictor=dlib.shape_predictor("/content/shape_predictor_68_face_landmarks.dat")
faces=detector(imggray)
for face in faces:
  landmarks=predictor(imggray,face)
  l=[]
  for n in range(0,68):
    x=landmarks.part(n).x
    y=landmarks.part(n).y
    l.append((x,y))
    #cv2.circle(img,(x,y),3,(0,0,255),-1)
  point=np.array(l,dtype=np.int32)
  convexhull=cv2.convexHull(point)
  #print(convexhull)
  #cv2.polylines(img,[convexhull],True,(255,0,0),3)
  cv2.fillConvexPoly(mask,convexhull,255)
  face_1=cv2.bitwise_and(img,img, mask=mask)
  rect=cv2.boundingRect(convexhull)
  #(x,y,w,h)=rect
  #cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0))
  subdiv=cv2.Subdiv2D(rect)
  subdiv.insert(l)
  triangles=subdiv.getTriangleList()
  index_triangles=[]
  for i in triangles:
    p1=(int(i[0]),int(i[1]))
    p2=(int(i[2]),int(i[3]))
    p3=(int(i[4]),int(i[5]))
    #print(p1)
    index_p1=np.where((point==p1).all(axis=1))
    index_p1=get_index(index_p1)
    #print(index_p1)
    index_p2=np.where((point==p2).all(axis=1))
    index_p2=get_index(index_p2)
    index_p3=np.where((point==p3).all(axis=1))
    index_p3=get_index(index_p3)
    #print(index_p1)
    if index_p1 is not None and index_p2 is not None and index_p3 is not None:
      triangle=[index_p1,index_p2,index_p3]
      index_triangles.append(triangle)
    #cv2.line(img,p1,p2,(0,0,255),2)
    #cv2.line(img,p3,p2,(0,0,255),2)
    #cv2.line(img,p3,p1,(0,0,255),2)
  print(index_triangles)
  #print(triangles)
#cv2_imshow(img)
#cv2_imshow(face_1)

faces_1=detector(img_1gray)
for face in faces_1:
  landmarks_1=predictor(img_1gray,face)
  l1=[]
  for n in range(0,68):
    x=landmarks_1.part(n).x
    y=landmarks_1.part(n).y
    l1.append((x,y))
for triangle in index_triangles:
# Image-1
  p1=l[triangle[0]]
  p2=l[triangle[1]]
  p3=l[triangle[2]]

  #cv2.line(img,p1,p2,(0,0,255),2)
  #cv2.line(img,p3,p2,(0,0,255),2)
  #cv2.line(img,p3,p1,(0,0,255),2)
  triangle1=np.array([p1,p2,p3],np.int32)
  rect1=cv2.boundingRect(triangle1)
  (x,y,w,h)=rect1
  #cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0),2)
  cropped_triangle1=img[y:y+h,x:x+w]
  cropped_mask1=np.zeros((h,w),np.uint8)
  point1=np.array([[p1[0]-x,p1[1]-y],[p2[0]-x,p2[1]-y],[p3[0]-x,p3[1]-y]])
  cv2.fillConvexPoly(cropped_mask1,point1,255)
  cropped_triangle1=cv2.bitwise_and(cropped_triangle1,cropped_triangle1,mask=cropped_mask1)
# Image-2
  pt1=l1[triangle[0]]
  pt2=l1[triangle[1]]
  pt3=l1[triangle[2]]

  #cv2.line(img_1,pt1,pt2,(0,0,255),2)
  #cv2.line(img_1,pt3,pt2,(0,0,255),2)
  #cv2.line(img_1,pt3,pt1,(0,0,255),2)
  triangle2=np.array([pt1,pt2,pt3],np.int32)
  rect2=cv2.boundingRect(triangle2)
  (x,y,w,h)=rect2
  #cv2.rectangle(img_1,(x,y),(x+w,y+h),(0,255,0),2)
  cropped_triangle2=img_1[y:y+h,x:x+w]
  cropped_mask2=np.zeros((h,w),np.uint8)
  point2=np.array([[pt1[0]-x,pt1[1]-y],[pt2[0]-x,pt2[1]-y],[pt3[0]-x,pt3[1]-y]])
  cv2.fillConvexPoly(cropped_mask2,point2,255)
  cropped_triangle2=cv2.bitwise_and(cropped_triangle2,cropped_triangle2,mask=cropped_mask2)
  point_1=np.float32(point1)
  point_2=np.float32(point2)
  M=cv2.getAffineTransform(point_1,point_2)
  warped_triangle=cv2.warpAffine(cropped_triangle1,M,(w,h))
  triangle_area=img2_newface[y:y+h,x:x+w]
  #warped_triangle=cv2.blur(warped_triangle,(5,5))
  triangle_area=cv2.add(triangle_area,warped_triangle)
  #triangle_area=cv2.blur(triangle_area,(5,5))
  #cv2_imshow(triangle_area)
  img2_newface[y:y+h,x:x+w]=triangle_area
img2_newface_gray=cv2.cvtColor(img2_newface,cv2.COLOR_BGR2GRAY)
thresh_val = 200  # adjust this threshold value as needed
_, img_binary = cv2.threshold(img2_newface_gray, thresh_val, 255, cv2.THRESH_BINARY)
img2_newface = cv2.inpaint(img2_newface,img_binary,10,cv2.INPAINT_NS)
img2_newface_gray=cv2.cvtColor(img2_newface,cv2.COLOR_BGR2GRAY)
_,background=cv2.threshold(img2_newface_gray,0,255,cv2.THRESH_BINARY)
#_,background1=cv2.threshold(img2_newface_gray,0,255,cv2.THRESH_BINARY_INV)
#backgroundf=cv2.bitwise_and(img_1,img_1,mask=background1)
#result=cv2.add(backgroundf,img2_newface)
point_sub=np.array(l1,np.int32)
convexhull2=cv2.convexHull(point_sub)
img2_face_mask = np.zeros_like(img_1gray)
img2_head_mask = cv2.fillConvexPoly(img2_face_mask, convexhull2, 255)
img2_face_mask = cv2.bitwise_not(img2_head_mask)
img2_head_noface = cv2.bitwise_and(img_1, img_1, mask=img2_face_mask)
img2_head_noface=cv2.blur(img2_head_noface,(5,5))
result = cv2.add(img2_head_noface, img2_newface)
result=cv2.blur(result,(5,5))
(x, y, w, h) = cv2.boundingRect(convexhull2)
center_face2 = (int((x + x + w) / 2), int((y + y + h) / 2))
#center = (int(x+w*1),int(y+h*1))
seamlessclone = cv2.seamlessClone(result,img_1,background,center_face2,cv2.NORMAL_CLONE)
seamlessclone=cv2.blur(seamlessclone,(5,5))
#cv2_imshow(img2_head_noface)
#cv2_imshow(result)
#cv2_imshow(background)
#cv2_imshow(img2_newface)
cv2_imshow(seamlessclone )

#thresh_val = 210  # adjust this threshold value as needed
#_, img_binary = cv2.threshold(img2_newface_gray, thresh_val, 255, cv2.THRESH_BINARY)
#dst = cv2.inpaint(img2_newface,img_binary,10,cv2.INPAINT_NS)

#cv2_imshow(dst)

